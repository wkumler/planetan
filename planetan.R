
library(shiny)
library(plotly)
source("scripts/resource_creation.R")
options(browser=r"(C:\Program Files (x86)\Microsoft\Edge\Application\msedge.exe)")
anti_merge <- function(x, y, by) {
  x[!do.call(paste, x[by]) %in% do.call(paste, y[by]), ]
}
camera_eye <- function() {
  theta <- runif(1, 0, 2 * pi)
  c(1.2 * cos(theta), 1.2 * sin(theta))
}
moveMarkerOutward <- function(xyzframe, distance=0.5){
  if(nrow(xyzframe)==0){
    print("No markers to move outward")
    return(xyzframe)
  }
  just_xyz <- xyzframe[c("x", "y", "z")]
  new_xyz <- just_xyz %>%
    apply(1, cart2sphere) %>% 
    `+`(c(distance, 0, 0)) %>% 
    apply(2, sphere2cart) %>%
    t() %>% 
    setNames(c("x", "y", "z"))
  xyzframe[c("x", "y", "z")] <- new_xyz
  return(xyzframe)
}


# Deployment checklist
# Comment out all browseURL calls
# Comment out the game_files unlink code at bottom
# Remove all the "admin" and "newplayer" and "password" places and replace with ""
# Switch from QUNWYD to the autogenerated game_id line
# Switch from precompiled debug_resource_layout.rds to actual generation
# Save planetan.R as app.R
# runApp()
# Hit the "Republish" button in the top right


ui <- fillPage(
  uiOutput("visible_screen"),
  includeCSS("styles.css"),
  includeScript("colorbar.js")
)

server <- function(input, output, session){
  getGameData <- function(rds_obj_name, print_value=TRUE){
    # print(paste("Reading", rds_obj_name, "in from file"))
    value <- readRDS(paste0("game_files/", input$game_id, "/", rds_obj_name, ".rds"))
    # if(print_value)print(paste("Value:", value))
    return(value)
  }
  setGameData <- function(rds_obj_name, value, print_value=TRUE){
    print(paste("Saving", rds_obj_name, "into file"))
    saveRDS(value, paste0("game_files/", input$game_id, "/", rds_obj_name, ".rds"))
    # if(print_value)print(paste("Value:", value))
    return(NULL)
  }
  gameLog <- function(log_item){
    print(paste("LOG ITEM:", log_item))
    outfile <- paste0("game_files/", input$game_id, "/game_log.txt")
    all_lines <- readLines(outfile)
    cat(paste(c(log_item, all_lines, ""), collapse = "\n"), file = outfile)
    return(NULL)
  }
  getBuildSpots <- function(){
    print("Getting buildable spots!")
    build_list <- getGameData("build_list")
    player_resources <- getGameData("player_resources")
    
    player_res_row <- player_resources[player_resources$uname==input$uname,]
    build_spots <- integer()
    if(player_res_row$wood>=1 & player_res_row$brick>=1){
      my_roads <- build_list[build_list$build=="road" & build_list$owner==input$uname,]
      nearby_roads <- unique(unlist(merge(my_roads, nearby_structures$edges)$nearest_edges))
      road_spots <- setdiff(nearby_roads, build_list$id)
      build_spots <- c(build_spots, road_spots)
    }
    if(all(player_res_row[c("wood", "brick", "wool", "wheat")]>=1)){
      # settlements that are near our roads
      # that are not already built
      # that are not too close to other builds
      
      my_roads <- build_list[build_list$build=="road" & build_list$owner==input$uname,]
      potsets <- unique(unlist(merge(my_roads, nearby_structures$edges)$nearest_verts))
      
      all_settles <- build_list[build_list$build=="settlement",]
      too_close_to_settle <- unique(unlist(merge(all_settles, nearby_structures$verts)$nearest_verts))
      
      settle_spots <- setdiff(potsets, c(too_close_to_settle, build_list$id))
      build_spots <- c(build_spots, settle_spots)
    }
    if(player_res_row$ore>=3 & player_res_row$wheat>=2){
      my_settles <- build_list[build_list$build=="settlement" & build_list$owner==input$uname,]
      all_cities <- build_list[build_list$build=="city",]
      city_spots <- setdiff(my_settles$id, all_cities$id)
      build_spots <- c(build_spots, city_spots)
    }
    marker_data_all[marker_data_all$id%in%build_spots,]
  }
  
  # Setup initial values ----
  setup_initial_values <- TRUE
  if(setup_initial_values){
    # These vars are simple reactives because they're specific to this session
    login_status <- reactiveVal("startup")
    my_build_list <- reactiveVal(data.frame(id=numeric(), owner=character(), build=character()))
    my_marker_data <- reactiveVal(data.frame(id=numeric(), x=numeric(), y=numeric(), z=numeric(),
                                             compass_angle=numeric(), elevation_angle=numeric(),
                                             lab=character()))
    my_player_resources <- reactiveVal(data.frame(
      uname=character(), vp=numeric(), knights=numeric(),
      wood=numeric(), brick=numeric(), wool=numeric(), wheat=numeric(), ore=numeric()
    ))
    robber_spot <- data.frame(x=0, y=0, z=0, compass_angle=0, elevation_angle=0)
    my_robber_data <- reactiveVal(piece_maker(piece_type = "robber", robber_spot))
    robber_active <- reactiveVal(FALSE)
    color_num <- reactiveVal(runif(1))
    
    # These vars are fancy reactives because they're shared ACROSS sessions
    # All are converted to reactiveFileReaders once we have input$game_id
    init_player_list <- reactiveVal(function(){})
    game_status <- reactiveVal(function(){})
    current_player <- reactiveVal(function(){})
    build_list <- reactiveVal(function(){})
    marker_data <- reactiveVal(function(){})
    robber_data <- reactiveVal(function(){})
    player_resources <- reactiveVal(function(){})
    dice_rolled <- reactiveVal(function(){})
    log_reader <- reactiveVal(function(){})
    color_table <- reactiveVal(function(){})
    trade_status <- reactiveVal(function(){})
    trade_responses <- reactiveVal(function(){})
    proposed_trade <- reactiveVal(function(){})
  }
  
  # Determine screen outputs ----
  output$visible_screen <- renderUI({
    print("Rendering visible screen!")
    if(login_status()=="startup"){
      print("Returning startup_div")
      startup_div <- div(
        class = "center-both",
        wellPanel(
          h2("Welcome to Planetan!"),
          actionButton("new_game_button", "Host new game"),
          actionButton("join_game_button", "Join existing"),
        )
      )
      return(startup_div)
    }
    if(login_status()=="make_new_game"){
      print("Returning make_new_game_div")
      taken_game_ids <- readRDS("game_files/existing_game_ids.rds")
      suggested_game_id <- paste0(sample(LETTERS, 6, replace = TRUE), collapse = "")
      while(suggested_game_id%in%taken_game_ids){
        suggested_game_id <- paste0(sample(LETTERS, 6, replace = TRUE), collapse = "")
      }
      make_new_game_div <- div(
        class = "center-both",
        wellPanel(
          h3("Start a new game"),
          textInput("uname", label = "Pick a username:", value = "admin"),
          textInput("pwd", label = "Pick your password:", value = "password"),
          textInput("game_id", label = "Choose a game ID:", value = "QUNWYD"),
          # textInput("game_id", label = "Choose a game ID:", value = suggested_game_id),
          actionButton("host_ready_button", "Start hosting")
        )
      )
      return(make_new_game_div)
    }
    if(login_status()=="game_id_taken"){
      print("Returning game_id_taken_div")
      taken_game_ids <- readRDS("game_files/existing_game_ids.rds")
      suggested_game_id <- paste0(sample(LETTERS, 6, replace = TRUE), collapse = "")
      # Make sure we aren't suggesting an already-taken game ID
      while(suggested_game_id%in%taken_game_ids){
        suggested_game_id <- paste0(sample(LETTERS, 6, replace = TRUE), collapse = "")
      }
      game_id_taken_div <- div(
        class = "center-both",
        wellPanel(
          h3("Start a new game"),
          textInput("uname", label = "Pick a username:", value = "admin"),
          textInput("pwd", label = "Pick your password:", value = "password"),
          textInput("game_id", label = "Choose a game ID:", value = suggested_game_id),
          p("That game ID is already taken! Choose another.", style="color:red;"),
          actionButton("host_ready_button", "Start hosting")
        )
      )
      return(game_id_taken_div)
    }
    if(login_status()=="join_existing_game"){
      print("Returning join_existing_game_id_div")
      join_existing_game_div <- div(
        class = "center-both",
        wellPanel(
          h3("Join an existing game"),
          textInput("game_id", label = "Choose a game ID:", value = "QUNWYD"), # Remove value after debugging
          actionButton("attempt_join_button", paste("Find game"))
        )
      )
      return(join_existing_game_div)
    }
    if(login_status()=="game_id_not_found"){
      print("Returning game_id_not_found_div")
      game_id_not_found_div <- div(
        class = "center-both",
        wellPanel(
          h3("Join an existing game"),
          textInput("game_id", label = "Choose a game ID:"),
          p("Game ID not found! Try again or start a new game.", style="color:red;"),
          actionButton("attempt_join_button", paste("Find game")),
          actionButton("new_game_button", "Host new game")
        )
      )
      return(game_id_not_found_div)
    }
    if(login_status()=="found_game_id"){
      if(game_status()()=="players_joining"){
        print("Returning found_newgame_id_div")
        found_newgame_id_div <- div(
          class = "center-both",
          wellPanel(
            h3("Provide a username and password"),
            textInput("uname", label = "Username:", value = "newplayer"), #change back to newplayer eventually
            textInput("pwd", label = "Password:", value = "password"), #change back to alsopassword eventually
            actionButton("join_waiting_room", "Join game")
          )
        )
        return(found_newgame_id_div)
      } else {
        print("Returning found_game_id_div")
        found_game_id_div <- div(
          class = "center-both",
          wellPanel(
            h3("Provide your username and password"),
            textInput("uname", label = "Username:", value = "admin"), #change back to newplayer eventually
            textInput("pwd", label = "Password:", value = "password"), #change back to alsopassword eventually
            actionButton("rejoin_existing_game", "Join game")
          )
        )
        return(found_game_id_div)
      }
    }
    if(login_status()=="uname_already_taken"){
      print("Returning uname_already_taken_div")
      uname_already_taken_div <- div(
        class = "center-both",
        wellPanel(
          h3("Provide a username and password"),
          textInput("uname", label = "Username:", value = "admin"), #remove value eventually
          p("That username is already taken! Choose a different one.", style="color:red;"),
          textInput("pwd", label = "Password:", value = "password"), #remove value eventually
          actionButton("join_waiting_room", "Join game")
        )
      )
      return(uname_already_taken_div)
    }
    if(login_status()=="join_game_failed"){
      print("Returning join_game_failed_div")
      join_game_failed_div <- div(
        class = "center-both",
        wellPanel(
          h3("Provide a username and password"),
          textInput("uname", label = "Username:", value = "newplayer"),
          textInput("pwd", label = "Password:", value = "alsopassword"),
          p("Login failed! Try again or start a new game.", style="color:red;"),
          actionButton("join_waiting_room", "Join game"),
          actionButton("new_game_button", "Host new game")
        )
      )
      return(join_game_failed_div)
    }
    if(login_status()=="rejoin_game_failed"){
      print("Returning rejoin_game_failed_div")
      rejoin_game_failed_div <- div(
        class = "center-both",
        wellPanel(
          h3("Provide a username and password"),
          textInput("uname", label = "Username:", value = "newplayer"),
          textInput("pwd", label = "Password:", value = "alsopassword"),
          p("Login failed! Try again or start a new game.", style="color:red;"),
          actionButton("rejoin_existing_game", "Join game"),
          actionButton("new_game_button", "Host new game")
        )
      )
      return(rejoin_game_failed_div)
    }
    if(login_status()=="host_waiting"){
      print("Returning host_waiting_div")
      print(color_table()())
      print(init_player_list()())
      static_color_table <- getGameData("color_table")
      player_color_span <- HTML(paste("Current players:", paste0(
        "<span style='color:", static_color_table$pcolor, ";'>", static_color_table$uname, "</span>", 
        ifelse(seq_along(static_color_table$uname) < nrow(static_color_table), ", ", ""), collapse = "")
      ))
      print(player_color_span)
      host_waiting_div <- div(
        class = "center-both",
        wellPanel(
          h3("Waiting for players"),
          h3(paste("Game ID:", input$game_id)),
          h3(player_color_span),
          h3("   "),
          sliderInput("color_choice", label = "Choose a color!", min = 0, max = 1, value = color_num()),
          actionButton("game_start", "Start game!")
        )
      )
      return(host_waiting_div)
    }
    if(login_status()=="join_waiting"){
      print(paste("For", input$uname, ", game_status()() is", game_status()()))
      # Check whether game_status()() is "setup" or "players_joining"
      # Needs to observe in real time because at some point input$game_start
      # will convert it to "setup" for everyone, at which point we want to
      # skip this div and return the gameboard
      if(game_status()()=="players_joining"){
        print("Returning join_waiting_div")
        print(color_table()())
        print(init_player_list()())
        static_color_table <- getGameData("color_table")
        player_color_span <- HTML(paste("Current players:", paste0(
          "<span style='color:", static_color_table$pcolor, ";'>", static_color_table$uname, "</span>", 
          ifelse(seq_along(static_color_table$uname) < nrow(static_color_table), ", ", ""), collapse = "")
        ))
        join_waiting_div <- div(
          class = "center-both",
          wellPanel(
            h3("Waiting for host to start game"),
            h3(paste("Game ID:", input$game_id)),
            h3(player_color_span),
            h3("   "),
            sliderInput("color_choice", label = "Choose a color!", min = 0, max = 1, value = color_num()), # Change back to 1 later
          )
        )
        return(join_waiting_div)
      }
    }
    
    load_disk_reactives <- TRUE
    if(load_disk_reactives){
      # Load current_player()() here to avoid loading it separately for host and join
      current_player(reactiveFileReader(
        intervalMillis = 1000, 
        session = session, 
        filePath = paste0("game_files/", input$game_id, "/current_player.rds"), 
        readFunc = readRDS
      ))
      build_list(reactiveFileReader(
        intervalMillis = 1000, 
        session = session, 
        filePath = paste0("game_files/", input$game_id, "/build_list.rds"), 
        readFunc = readRDS
      ))
      robber_data(reactiveFileReader(
        intervalMillis = 1000, 
        session = session, 
        filePath = paste0("game_files/", input$game_id, "/robber_data.rds"), 
        readFunc = readRDS
      ))
      marker_data(reactiveFileReader(
        intervalMillis = 1000, 
        session = session, 
        filePath = paste0("game_files/", input$game_id, "/marker_data.rds"), 
        readFunc = readRDS
      ))
      player_resources(reactiveFileReader(
        intervalMillis = 1000, 
        session = session, 
        filePath = paste0("game_files/", input$game_id, "/player_resources.rds"), 
        readFunc = readRDS
      ))
      dice_rolled(reactiveFileReader(
        intervalMillis = 1000, 
        session = session, 
        filePath = paste0("game_files/", input$game_id, "/dice_rolled.rds"), 
        readFunc = readRDS
      ))
      trade_status(reactiveFileReader(
        intervalMillis = 1000, 
        session = session, 
        filePath = paste0("game_files/", input$game_id, "/trade_status.rds"), 
        readFunc = readRDS
      ))
      trade_responses(reactiveFileReader(
        intervalMillis = 1000, 
        session = session, 
        filePath = paste0("game_files/", input$game_id, "/trade_responses.rds"), 
        readFunc = readRDS
      ))
      proposed_trade(reactiveFileReader(
        intervalMillis = 1000, 
        session = session, 
        filePath = paste0("game_files/", input$game_id, "/proposed_trade.rds"), 
        readFunc = readRDS
      ))
      log_reader(reactiveFileReader(
        intervalMillis = 1000,
        session = session,
        filePath = paste0("game_files/", input$game_id, "/game_log.txt"),
        readFunc = readLines
      ))
    }

    if(game_status()()=="setup"){
      print("Returning setup div")
      color_table <- getGameData("color_table")
      player_color <- color_table[color_table$uname==input$uname,"pcolor"]
      uname_span <- span(style=paste0("color: ", player_color, ";"), input$uname)
      curp_color <- color_table[color_table$uname==current_player()(),"pcolor"]
      curp_span <- span(style=paste0("color: ", curp_color, ";"), current_player()())
      if(input$uname==current_player()()){
        setup_div <- tagList(
          sidebarPanel(
            h3(HTML(paste0("Welcome to Planetan, ", uname_span, "!"))),
            h4(paste("Game ID:", input$game_id)),
            h3("Choose a starting location by clicking on the globe."),
            actionButton("build_here_setup", label = "Build here", disabled = TRUE),
            div(class = "scrollable-log", verbatimTextOutput("game_log")),
            width=3
          ),
          mainPanel(
            plotlyOutput("setup_game_world", height = "100vh"),
            # div(id = "options-container", checkboxInput("rotate_world", label = "Auto rotate?", value=FALSE))
          )
        )
      } else {
        setup_div <- tagList(
          sidebarPanel(
            h3(HTML(paste0("Welcome to Planetan, ", uname_span, "!"))),
            h4(paste("Game ID:", input$game_id)),
            h4("Waiting for ", curp_span, " to choose setup spots."),
            div(class = "scrollable-log", verbatimTextOutput("game_log")),
            width=3
          ),
          mainPanel(
            plotlyOutput("setup_game_world", height = "100vh"),
            # div(id = "options-container", checkboxInput("rotate_world", label = "Auto rotate?", value=FALSE))
          )
        )
      }
      return(setup_div)
    }
    if(game_status()()=="gameplay"){
      print("Returning gameplay div")
      color_table <- getGameData("color_table")
      player_color <- color_table[color_table$uname==input$uname,"pcolor"]
      uname_span <- span(style=paste0("color: ", player_color, ";"), input$uname)
      curp_color <- color_table[color_table$uname==current_player()(),"pcolor"]
      curp_span <- span(style=paste0("color: ", curp_color, ";"), current_player()())
      my_res <- player_resources()()[player_resources()()$uname==input$uname,c("wood", "brick", "wool", "wheat", "ore")]
      colnames(my_res) <- sapply(colnames(my_res), function(x)paste0(toupper(substr(x, 1, 1)), substr(x, 2, nchar(x))))
      output$my_res <- renderTable(my_res)
      p_status <- merge(player_resources()(), init_player_list()())

      if(input$uname==current_player()()){
        gameplay_div <- tagList(
          sidebarPanel(
            h3(HTML(paste0("Welcome to Planetan, ", uname_span, "!"))),
            h4(paste("Game ID:", input$game_id)),
            if(robber_active()){
              tagList(
                h3("Robber active! Choose where it should go."),
                actionButton("move_robber", "Move the robber here", disabled = TRUE)
              )
            } else {
              if(dice_rolled()()==FALSE){ # Has to be reactive to trigger rerender
                if(player_resources()()$knights[player_resources()()$uname==input$uname]>0){
                  tagList(
                    h3("Roll the dice or play a knight"),
                    actionButton("roll_dice", "Roll the dice"),
                    actionButton("play_knight", "Play a knight")
                  )
                } else {
                  tagList(
                    h3(HTML("Roll the dice to begin your&nbsp;turn")),
                    actionButton("roll_dice", "Roll the dice")
                  )
                }
              } else {
                top_taglist <- tagList(
                  h3("Choose an action:"),
                  actionButton("build_here", "Build here", disabled = TRUE),
                  actionButton("offer_trade", "Offer a trade")
                )
                if(all(player_resources()()[player_resources()()$uname==input$uname, c("wheat", "wool", "ore")]>0)){
                  top_taglist <- c(top_taglist, tagList(actionButton("buy_devcard", "Buy a development card")))
                }
                if(player_resources()()$knights[player_resources()()$uname==input$uname]>0){
                  top_taglist <- c(top_taglist, tagList(actionButton("play_knight", "Play a knight")))
                }
                top_taglist <- c(top_taglist, tagList(actionButton("end_turn", "End turn")))
              }
            },
            div(class = "scrollable-log", verbatimTextOutput("game_log")),
            HTML(paste0(
              "<div style='margin-top:20px;'>",
              "<table class='custom-table'><thead><tr>",
              paste0("<th style='color:", c("transparent", p_status$pcolor), ";'>", c("", p_status$uname), "</th>", collapse = ""), "</tr>",
              "</thead><tbody>",
              "<tr><td>Victory Points</td>", paste0("<td>", p_status$vp, "</td>", collapse = ""), "</tr>",
              "<tr><td>Dev Cards</td>", paste0("<td>", p_status$knights, "</td>", collapse = ""), "</tr>",
              "</tbody></table></div>"
            )),
            h4("Current resources:"),
            tableOutput("my_res"),
            width=3
          ),
          mainPanel(
            plotlyOutput("game_world", height = "100vh"),
            # div(id = "options-container", checkboxInput("rotate_world", label = "Auto rotate?", value=FALSE))
          )
        )
      } else {
        gameplay_div <- tagList(
          sidebarPanel(
            h3(HTML(paste0("Welcome to Planetan, ", uname_span, "!"))),
            h4(paste("Game ID:", input$game_id)),
            h4("Waiting for ", curp_span, " to finish their turn."),
            div(class = "scrollable-log", verbatimTextOutput("game_log")),
            HTML(paste0(
              "<div style='margin-top:20px;'>",
              "<table class='custom-table'><thead><tr>",
              paste0("<th style='color:", c("transparent", p_status$pcolor), ";'>", c("", p_status$uname), "</th>", collapse = ""), "</tr>",
              "</thead><tbody>",
              "<tr><td>Victory Points</td>", paste0("<td>", p_status$vp, "</td>", collapse = ""), "</tr>",
              "<tr><td>Dev Cards</td>", paste0("<td>", p_status$knights, "</td>", collapse = ""), "</tr>",
              "</tbody></table></div>"
            )),
            h4("Current resources:"),
            tableOutput("my_res"),
            width=3
          ),
          mainPanel(
            plotlyOutput("game_world", height = "100vh"),
            # div(id = "options-container", checkboxInput("rotate_world", label = "Auto rotate?", value=FALSE))
          )
        )
      }
      return(gameplay_div)
    }
    if(game_status()()=="trade_offered"){
      if(trade_status()()=="init_deciding"){
        if(current_player()()==input$uname){
          print("Returning trade_setup_div")
          my_res <- player_resources()()[player_resources()()$uname==input$uname,c("wood", "brick", "wool", "wheat", "ore")]
          colnames(my_res) <- sapply(colnames(my_res), function(x)paste0(toupper(substr(x, 1, 1)), substr(x, 2, nchar(x))))
          output$my_res <- renderTable(my_res)
          trade_setup_div <- div(
            class = "center-both",
            wellPanel(
              h3("Choose your trade offer:"),
              h3("Request:", style="text-align: center;"),
              fluidRow(
                column(1),
                column(2, actionButton("wood_plus", max(0, n_wood()), class = "custom-button-padding"), div(class = "center-content", span("Wood")), actionButton("wood_minus", -min(0, n_wood()), class = "custom-button-padding")),
                column(2, actionButton("brick_plus", max(0, n_brick()), class = "custom-button-padding"), div(class = "center-content", span("Brick")), actionButton("brick_minus", -min(0, n_brick()), class = "custom-button-padding")),
                column(2, actionButton("wool_plus", max(0, n_wool()), class = "custom-button-padding"), div(class = "center-content", span("Wool")), actionButton("wool_minus", -min(0, n_wool()), class = "custom-button-padding")),
                column(2, actionButton("wheat_plus", max(0, n_wheat()), class = "custom-button-padding"), div(class = "center-content", span("Wheat")), actionButton("wheat_minus", -min(0, n_wheat()), class = "custom-button-padding")),
                column(2, actionButton("ore_plus", max(0, n_ore()), class = "custom-button-padding"), div(class = "center-content", span("Ore")), actionButton("ore_minus", -min(0, n_ore()), class = "custom-button-padding")),
                column(1)
              ),
              h3("Offer:", style="text-align: center;"),
              h4("You have:"),
              tableOutput("my_res"),
              actionButton("propose_trade", "Propose trade"),
              actionButton("cancel_trade", "Cancel")
            )
          )
        }
        if(current_player()()!=input$uname){
          trade_setup_div <- div(
            class = "center-both",
            wellPanel(
              h3(paste(current_player()(), "is deciding on a trade offer...")),
            )
          )
        }
        return(trade_setup_div)
      }
      if(trade_status()()=="awaiting_response"){
        print("Returning offer_div")
        if(current_player()()==input$uname){
          print("Returning offered_div")
          print(trade_responses()())
          nonhost_resp <- trade_responses()()[trade_responses()()$uname!=input$uname,]
          print(nonhost_resp)
          pretty_responses <- as.data.frame(t(setNames(nonhost_resp$response, nonhost_resp$uname)))
          radio_options <- nonhost_resp[nonhost_resp$response=="accept","uname"]
          print(radio_options)
          if(all(nonhost_resp$response=="reject")){
            print("Nobody wanted to trade")
            offered_div <- div(
              class = "center-both",
              wellPanel(
                h3("Nobody accepted your offer!"),
                actionButton("cancel_trade", label = "Cancel trade")
              )
            )
            return(offered_div)
          }
          if(length(radio_options)==0){
            print("Nobody responded yet...")
            offered_div <- div(
              class = "center-both",
              wellPanel(
                h3("Waiting for other players to"),
                h3("decide on your offer..."),
                actionButton("cancel_trade", label="Cancel")
              )
            )
            return(offered_div)
          }
          offered_div <- div(
            class = "center-both",
            wellPanel(
              h3("Waiting for other players to"),
              h3("decide on your offer..."),
              tableOutput(pretty_responses),
              radioButtons("trade_partner", label = "Who would you like to trade with?", 
                           choices = radio_options, character(0)),
              actionButton("choose_partner", label = "Make the trade"),
              actionButton("cancel_trade", label="Cancel")
            )
          )
        }
        if(current_player()()!=input$uname){
          my_res <- player_resources()()[player_resources()()$uname==input$uname,c("wood", "brick", "wool", "wheat", "ore")]
          colnames(my_res) <- sapply(colnames(my_res), function(x)paste0(toupper(substr(x, 1, 1)), substr(x, 2, nchar(x))))
          output$my_res <- renderTable(my_res)
          top_taglist <- tagList(
            h3(paste0("Make this trade with ", current_player()(), "?")),
            h4(paste0("You receive: ", paste(-(proposed_trade()()[proposed_trade()()<0]), 
                                             names(proposed_trade()())[proposed_trade()()<0], 
                                             collapse = ", "))),
            h4(paste0("You provide: ", paste(proposed_trade()()[proposed_trade()()>0], 
                                             names(proposed_trade()())[proposed_trade()()>0], 
                                             collapse = ", "))),
            h4("You have:"),
            tableOutput("my_res")
          )
          if(all(my_res>=proposed_trade()())){
            offered_div <- div(
              class = "center-both",
              wellPanel(
                c(top_taglist, tagList(
                  fluidRow(
                    column(6, actionButton("accept_proposal", "Accept")),
                    column(6, actionButton("reject_proposal", "Reject"))
                  )
                ))
              )
            )
          } else {
            offered_div <- div(
              class = "center-both",
              wellPanel(
                c(top_taglist, tagList(
                  h3("You don't have the required resources!"),
                  actionButton("reject_proposal", "Reject")
                ))
              )
            )
          }
        }
        return(offered_div)
      }
    }
    if(game_status()()=="game_won"){
      print("Returning game_won div!")
      color_table <- getGameData("color_table")
      player_color <- color_table[color_table$uname==current_player()(),"pcolor"]
      uname_span <- span(style=paste0("color: ", player_color, ";"), current_player()())
      game_won_div <- div(
        class = "center-both",
        wellPanel(
          h3(uname_span, " won this game!"),
          actionButton("new_game_button", "Start a new one?")
        )
      )
      return(game_won_div)
    }
    div(class = "center-both", wellPanel(h3("Loading world, please wait...")))
  }) # end output$visible_screen
  
  # observeEvent reactives()() that are input$game_id-dependent ----
  observeEvent(build_list()(), {
    print(paste("build_list()() triggered for", input$uname))
    
    new_build_data <- anti_merge(build_list()(), my_build_list(), by=c("id", "build"))
    if(nrow(new_build_data)==0){
      print("No new builds to add")
      return(NULL)
    }
    color_table <- getGameData("color_table")
    colnames(color_table) <- c("owner", "pcolor")
    new_build_data <- merge(new_build_data, color_table)
    new_build_row_data <- merge(new_build_data[,c("id", "build", "pcolor"),drop=FALSE], marker_data_unmoved)
    new_build_row_list <- split(new_build_row_data, seq_len(nrow(new_build_row_data)))
    new_geoms <- mapply(piece_maker, new_build_row_data$build, new_build_row_list, 
                        color= new_build_row_data$pcolor, SIMPLIFY = FALSE)
    new_geom_combined <- combine_geoms(new_geoms)
    
    nvert_piece_vals <- data.frame(build=c("city", "settlement", "road"), nvert=c(80, 20, 10))
    globe_plates <- getGameData("globe_plates", print_value = FALSE)
    nvert_globe_plates <- nrow(globe_plates$vertices)
    mesh_offset <- sum(merge(my_build_list(), nvert_piece_vals, all.y = FALSE)$nvert) + nvert_globe_plates
    
    newtrace <- list(
      x=list(as.list(new_geom_combined$vertices$x)),
      y=list(as.list(new_geom_combined$vertices$y)),
      z=list(as.list(new_geom_combined$vertices$z)),
      i=list(as.list(new_geom_combined$faces$i+mesh_offset)),
      j=list(as.list(new_geom_combined$faces$j+mesh_offset)),
      k=list(as.list(new_geom_combined$faces$k+mesh_offset)),
      facecolor=list(as.list(new_geom_combined$faces$color))
    )
    if(getGameData("game_status")=="setup"){
      print("Placing new mesh on setup_game_world")
      plotlyProxy("setup_game_world") %>% plotlyProxyInvoke("extendTraces", newtrace, list(0))
    } else {
      print("Placing new mesh on game_world")
      plotlyProxy("game_world") %>% plotlyProxyInvoke("extendTraces", newtrace, list(0))
    }
    
    print("Updating my_build_list to match disk")
    my_build_list(build_list()())
  })
  observeEvent(robber_data()(), {
    print(paste("robber_data()() triggered for", input$uname))
    if(identical(my_robber_data(), robber_data()())){
      print("Robber is in correct spot already")
      return(NULL)
      my_marker_data(FALSE)
      # setGameData("marker_data", getBuildSpots())
    }
    
    print("Removing existing robber (and any clickables)")
    plotlyProxy("game_world") %>% plotlyProxyInvoke("deleteTraces", list(3))
    plotlyProxy("game_world") %>% plotlyProxyInvoke("deleteTraces", list(2))
    plotlyProxy("game_world") %>% plotlyProxyInvoke("deleteTraces", list(1))
    
    print("Adding robber mesh to game_world")
    robber_init <- getGameData("robber_data")
    newtrace <- list(
      type="mesh3d",
      x=as.list(robber_init$vertices$x),
      y=as.list(robber_init$vertices$y),
      z=as.list(robber_init$vertices$z),
      i=as.list(robber_init$faces$i),
      j=as.list(robber_init$faces$j),
      k=as.list(robber_init$faces$k),
      facecolor=as.list(robber_init$faces$color),
      hoverinfo="none"
    )
    plotlyProxy("game_world") %>% plotlyProxyInvoke("addTraces", list(newtrace))
    
    my_robber_data(robber_data()())
  })
  observeEvent(marker_data()(), {
    print(paste("marker_data()() triggered for", input$uname))

    # if(identical(my_marker_data(), marker_data()())){
    #   print("No markers to add!")
    #   return(NULL)
    # }
    plotlyProxy("setup_game_world") %>% plotlyProxyInvoke("deleteTraces", list(3))
    plotlyProxy("setup_game_world") %>% plotlyProxyInvoke("deleteTraces", list(2))
    plotlyProxy("game_world") %>% plotlyProxyInvoke("deleteTraces", list(3))
    plotlyProxy("game_world") %>% plotlyProxyInvoke("deleteTraces", list(2))
    
    if(nrow(marker_data()())==0){
      print("No markers to add")
      my_marker_data(marker_data()())
      return(NULL)
    }
    if(game_status()()=="game_won"){
      return(NULL)
    }
    
    if(input$uname==getGameData("current_player")){
      if(getGameData("dice_rolled") | game_status()()=="setup" | robber_active()){
        print(paste("Adding clickables to map for", input$uname))
        static_marker_data <- marker_data()()
        city_spots <- getGameData("build_list")
        city_spots <- city_spots[city_spots$build=="settlement",]$id
        if(length(city_spots)>0){
          static_marker_data[static_marker_data$id%in%city_spots,] <- 
            moveMarkerOutward(static_marker_data[static_marker_data$id%in%city_spots,], 1)
        }
        static_marker_data$textlab <- ifelse(static_marker_data$lab=="edge", "road", 
                                             ifelse(static_marker_data$id%in%city_spots, "city", "settlement"))
        newtrace <- list(
          x = as.list(static_marker_data$x),
          y = as.list(static_marker_data$y),
          z = as.list(static_marker_data$z),
          key = as.list(static_marker_data$id),
          text = as.list(static_marker_data$textlab), 
          hoverinfo = "text",
          hovertemplate=paste0("Build a %{text}?<extra></extra>"),
          type = "scatter3d",
          mode = "markers",
          marker = list(color="white", opacity=0.1, size=50)
        )
        plotlyProxy("setup_game_world") %>% plotlyProxyInvoke("addTraces", newtrace)
        plotlyProxy("game_world") %>% plotlyProxyInvoke("addTraces", newtrace)
      }
    } else {
      print(paste("No markers to add for", input$uname))
    }
    print("Updating my_marker_data to match disk")
    my_marker_data(marker_data()())
  })
  observeEvent(player_resources()(), {
    print(paste("player_resources()() triggered for", input$uname))
    if(any(player_resources()()$vp>=10)){
      game_winner <- player_resources()()$uname[player_resources()()$vp>=10]
      setGameData("game_status", "game_won")
      setGameData("current_player", game_winner)
    }
    if(identical(my_player_resources(), player_resources()())){
      print("No resource update needed")
      return(NULL)
    }
    my_player_resources(player_resources()())
  })
  
  # Initialize players and game buttons ----
  observeEvent(input$new_game_button, {
    print("input$new_game_button clicked")
    login_status("make_new_game")
  })
  observeEvent(input$host_ready_button, {
    print("input$host_ready_button clicked")
    # When "Start hosting!" button is clicked:
    # Create the game files
    # Set login_status to "host_waiting"
    # Redirect to page with current players
    
    # Ensure new game IDs are saved AFTER checking whether ID is taken :p
    if(input$game_id%in%readRDS("game_files/existing_game_ids.rds")){
      login_status("game_id_taken")
      return(NULL)
    }
    login_status("host_waiting")

    existing_game_ids <- readRDS("game_files/existing_game_ids.rds")
    saveRDS(c(existing_game_ids, input$game_id), "game_files/existing_game_ids.rds")
    dir.create(paste0("game_files/", input$game_id))
    file.create(paste0("game_files/", input$game_id, "/game_log.txt"))
    gameLog(paste0("Host (", input$uname, ") started a new game"))
    setGameData("game_status", "players_joining")
    setGameData("init_player_list", data.frame(uname=input$uname, pwd=input$pwd))
    setGameData("color_table", data.frame(uname=input$uname, pcolor="#FF0000"))
    
    resource_layout <- getRandomGlobeLayout()
    built_world <- worldbuilder(resource_layout)
    # resource_layout <- readRDS("debug_resource_layout.rds")
    # built_world <- readRDS("debug_globe_plates.rds")
    setGameData("resource_layout", resource_layout, print_value = FALSE)
    setGameData("globe_plates", built_world, print_value = FALSE)
    
    init_player_list(reactiveFileReader(
      intervalMillis = 1000, 
      session = session, 
      filePath = paste0("game_files/", input$game_id, "/init_player_list.rds"), 
      readFunc = readRDS
    ))
    game_status(reactiveFileReader(
      intervalMillis = 1000, 
      session = session, 
      filePath = paste0("game_files/", input$game_id, "/game_status.rds"), 
      readFunc = readRDS
    ))
    color_table(reactiveFileReader(
      intervalMillis = 1000,
      session = session,
      filePath = paste0("game_files/", input$game_id, "/color_table.rds"), 
      readFunc = readRDS
    ))
  })
  observeEvent(input$join_game_button, {
    print("input$join_game_button clicked")
    login_status("join_existing_game")
  })
  observeEvent(input$attempt_join_button, {
    print("input$attempt_join_button clicked")
    print(paste("Attempting to join game ID", input$game_id))
    if(!input$game_id%in%readRDS("game_files/existing_game_ids.rds")){
      login_status("game_id_not_found")
    } else {
      login_status("found_game_id")
      # Initialize observer so that we can see when game_status.rds changes to "setup"
      # This observation doesn't happen here but instead above in input$game_start section
      game_status(reactiveFileReader(
        intervalMillis = 1000, 
        session = session, 
        filePath = paste0("game_files/", input$game_id, "/game_status.rds"), 
        readFunc = readRDS
      ))
      color_table(reactiveFileReader(
        intervalMillis = 1000,
        session = session,
        filePath = paste0("game_files/", input$game_id, "/color_table.rds"), 
        readFunc = readRDS
      ))
    }
  })
  observeEvent(input$join_waiting_room, {
    print("input$join_waiting_room clicked")
    init_player_list(reactiveFileReader(
      intervalMillis = 1000, 
      session = session, 
      filePath = paste0("game_files/", input$game_id, "/init_player_list.rds"), 
      readFunc = readRDS
    ))
    if(input$uname%in%init_player_list()()$uname){
      login_status("uname_already_taken")
    } else {
      new_player_table <- rbind(init_player_list()(), c("uname"=input$uname, "pwd"=input$pwd))
      setGameData("init_player_list", new_player_table)
      
      color_table <- getGameData("color_table")
      color_table <- rbind(color_table, data.frame(uname=input$uname, pcolor="#FF0000"))
      setGameData("color_table", color_table)
      
      gameLog(paste0("Player ", input$uname, " joined"))
      login_status("join_waiting")
    }
  })
  observeEvent(input$rejoin_existing_game, {
    init_player_list(reactiveFileReader(
      intervalMillis = 1000, 
      session = session, 
      filePath = paste0("game_files/", input$game_id, "/init_player_list.rds"), 
      readFunc = readRDS
    ))
    if(!input$uname%in%init_player_list()()$uname){
      login_status("rejoin_game_failed")
      return(NULL)
    }
    player_row <- which(init_player_list()()$uname==input$uname)
    if(input$pwd!=init_player_list()()$pwd[player_row]){
      login_status("rejoin_game_failed")
      return(NULL)
    }
    login_status("success")
  })
  observeEvent(input$color_choice, {
    if(game_status()()=="players_joining"){
      print("input$color_choice triggered!")
      color_table <- getGameData("color_table")
      player_row <- which(color_table$uname==input$uname)
      color_table$pcolor[player_row] <- hsv((1-input$color_choice)*315/360)
      setGameData("color_table", color_table)
      color_num(input$color_choice)
    }
  })
  observeEvent(input$game_start, {
    print("input$game_start clicked")
    # When "Start game!" button is clicked:
    # Create player_table and write to RDS
    # Decide who goes first and write out player_table in order
    # Set login status to "success" so all login_status steps get skipped
    # Set game_status to "setup"
    print("Starting game!")
    login_status("success")
    new_play_order <- merge(init_player_list()(), getGameData("color_table"))
    new_play_order <- new_play_order[sample(1:nrow(new_play_order)),]
    
    setGameData("init_player_list", new_play_order)
    setGameData("current_player", new_play_order$uname[1])
    setGameData("marker_data_all", marker_data_all, print_value = FALSE)
    setGameData("marker_data_unmoved", marker_data_unmoved, print_value = FALSE)
    setGameData("nearby_structures", nearby_structures, print_value = FALSE)
    setGameData("build_list", data.frame(id=numeric(), owner=character(), build=character()))
    setGameData("marker_data", marker_data_all[marker_data_all$lab=="vertex",])
    setGameData("robber_data", piece_maker(
      piece_type = "robber", data.frame(x=0, y=0, z=0, compass_angle=0, elevation_angle=0))
    )
    setGameData("player_resources", data.frame(
      uname=init_player_list()()$uname, vp=2, knights=0,
      wood=0, brick=0, wool=0, wheat=0, ore=0
    ))
    setGameData("dice_rolled", FALSE)
    setGameData("trade_status", "init_deciding")
    setGameData("trade_responses", data.frame(uname=init_player_list()()$uname, response="Undecided"))
    setGameData("proposed_trade", data.frame(wood=0, brick=0, wool=0, wheat=0, ore=0))
    setGameData("game_status", "setup")
    gameLog("Game started")
  })
  
  # Globe render things ----
  output$game_log <- renderText({
    req(input$game_id)
    req(game_status()())
    paste(log_reader()(), collapse = "\n")
  })
  observe({
    i <- 0
    theta <- seq(0, 6 * pi, length.out = 360) 
    r <- sqrt(1.5^2 - (0.8*sin(theta/3))^2)
    cam_coords <- data.frame(x = r*cos(theta), y = r*sin(theta), z = 0.8*sin(theta/3))
    req(input$rotate_world)
    if(input$rotate_world){
      if(game_status()()=="setup"){
        p <- plotlyProxy("setup_game_world", session)
      } else {
        p <- plotlyProxy("game_world", session)
      }
      i <<- (i + 1) %% 360
      set_axis <- list(showspikes=FALSE, showgrid=FALSE, zeroline=FALSE, 
                       visible=FALSE, range=c(-15, 15))
      plotlyProxyInvoke(p, "relayout", 
                        list(scene = list(camera = list(eye = list(
                          x = cam_coords[i,"x"],
                          y = cam_coords[i,"y"],
                          z = cam_coords[i,"z"])
                        ), bgcolor="black", aspectmode="cube",
                        xaxis=set_axis, yaxis=set_axis, zaxis=set_axis)))
    }
    invalidateLater(100, session)
  }) # move camera
  
  # Setup observeEvents and output$setup_game_world ----
  output$setup_game_world <- renderPlotly({
    print("Re-rendering setup_game_world")
    globe_plates <- getGameData("globe_plates", print_value = FALSE)

    set_axis <- list(range=max(abs(globe_plates$vertices))*c(-1.05, 1.05),
                     autorange=FALSE, showspikes=FALSE,
                     showgrid=FALSE, zeroline=FALSE, visible=FALSE)
    # Maybe build ply() as a reactive object (static object?)
    # at the same time that the world itself is built?
    start_camera <- camera_eye()
    ply <- plot_ly(source = "setup_game_world") %>%
      add_trace(type="mesh3d", data = globe_plates,
                x=~vertices$x, y=~vertices$y, z=~vertices$z,
                i=~faces$i, j=~faces$j, k=~faces$k,
                facecolor=rgb(t(col2rgb(globe_plates$faces$color)),
                              maxColorValue = 255),
                lighting=list(diffuse=1),
                hoverinfo="none") %>%
      layout(scene=list(
        xaxis=set_axis, yaxis=set_axis, zaxis=set_axis,
        aspectmode='cube',
        camera=list(eye=list(x=start_camera[1], y=start_camera[2], z=0.8)),
        bgcolor="black"
      ),
      margin=list(l=0, r=0, b=0, t=0, pad=0),
      showlegend=FALSE) %>%
      config(displayModeBar = FALSE)
    
    robber_init <- getGameData("robber_data")
    ply <- ply %>%
      add_trace(type="mesh3d", data = robber_init,
                x=~vertices$x, y=~vertices$y, z=~vertices$z,
                i=~faces$i, j=~faces$j, k=~faces$k,
                facecolor=rgb(t(col2rgb(robber_init$faces$color)),
                              maxColorValue = 255),
                lighting=list(diffuse=1),
                hoverinfo="none")
    
    if(isolate(current_player()())==input$uname){
      ply <- ply %>%
        add_trace(type="scatter3d", data=marker_data_all[marker_data_all$lab=="vertex",],
                  x=~x, y=~y, z=~z, key=~id, text="settlement", hoverinfo="text",
                  mode="markers", marker=list(color="white", opacity=0.1, size=50),
                  hovertemplate=paste0("Build a %{text}?<extra></extra>"))
    }
    
    # Trace 0 = globe
    # Trace 1 = robber
    # Trace 2 = all markers
    # Trace 3 = selected spot: setup_ed()
    return(ply)
  })
  setup_ed <- reactive(event_data(event = "plotly_click", source = "setup_game_world"))
  observeEvent(setup_ed(), {
    req(setup_ed()$key) # Prevent clicks on the GLOBE (not markers) from registering
    print("setup_game_world clicked!")
    print(setup_ed())
    if(setup_ed()$key%in%1:60){
      hovertext <- "Build a settlement here?"
    } else {
      hovertext <- "Build a road here?"
    }
    plotlyProxy("setup_game_world") %>% plotlyProxyInvoke("deleteTraces", list(3)) # Remove colored trace if it exists
    newtrace <- list(x = list(setup_ed()$x), 
                     y = list(setup_ed()$y), 
                     z=list(setup_ed()$z), 
                     key=list(setup_ed()$key), 
                     text=list(hovertext),
                     hoverinfo="text",
                     type = "scatter3d",
                     mode = "markers", 
                     marker=list(color="red", opacity=0.2, size=50)
                     )

    plotlyProxy("setup_game_world") %>% plotlyProxyInvoke("addTraces", newtrace)
    
    updateActionButton(session, "build_here_setup", label = "Build here", disabled = FALSE)
  })
  observeEvent(input$build_here_setup, {
    req(setup_ed()$key)
    print("input$build_here_setup clicked")
    updateActionButton(session, "build_here_setup", label = "Build here", disabled = TRUE)
    
    print("Updating build_list()()")
    marker_data_unmoved <- getGameData("marker_data_unmoved", print_value = FALSE)
    build_spot <- marker_data_unmoved[setup_ed()$key,]
    build_type <- ifelse(build_spot$lab=="edge", "road", "settlement")
    new_build <- data.frame(id=build_spot$id, owner=input$uname, build=build_type)
    setGameData("build_list", rbind(build_list()(), new_build))
    gameLog(paste0(input$uname, " built a ", new_build$build))
    
    if(new_build$build=="road"){
      print("Updating marker_data()()")
      init_settlement_spots <- marker_data_all[marker_data_all$lab=="vertex",]
      built_verts <- init_settlement_spots[build_list()()$id,]
      too_close_verts <- unique(unlist(merge(built_verts, nearby_structures$verts)$nearest_verts))
      marker_spots <- init_settlement_spots[!init_settlement_spots$id%in%too_close_verts,]
      marker_spots <- marker_spots[!marker_spots$id%in%built_verts$id,]
    } else {
      init_settlement_spots <- marker_data_all[marker_data_all$lab=="edge",]
      nearby_edges <- unlist(nearby_structures$verts$nearest_edges[new_build$id])
      marker_spots <- init_settlement_spots[init_settlement_spots$id%in%nearby_edges,]
    }
    print("Updating marker_data()()")
    setGameData("marker_data", marker_spots)
    
    setup_stack <- init_player_list()()$uname
    setup_stack <- c(setup_stack, rev(setup_stack), "begin")
    next_player <- setup_stack[floor(nrow(getGameData("build_list"))/2)+1]
    if(next_player=="begin"){
      setGameData("game_status", "gameplay")
      setGameData("current_player", setup_stack[1])
      setGameData("marker_data", getBuildSpots())
      gameLog("Setup complete! Starting gameplay.")
      
      # Allocate initial resources to players
      resource_layout <- getGameData("resource_layout")
      settle_resources <- build_list()()[build_list()()$build=="settlement",] %>%
        .[duplicated(.$owner),] %>%
        merge(nearby_structures$verts)
      unlist_resources <- data.frame(
        vert_id=rep(settle_resources$id, each=3),
        owner=rep(settle_resources$owner, each=3),
        id=unlist(settle_resources$nearest_faces)
      ) %>% 
        merge(resource_layout[c("id", "hex_resources")]) %>%
        .[.$hex_resources!="snow",]
      static_player_resources <- getGameData("player_resources")
      for(i in seq_len(nrow(unlist_resources))){
        player_row <- which(static_player_resources$uname==unlist_resources$owner[i])
        resource_col <- as.character(unlist_resources$hex_resources[i])
        static_player_resources[player_row,resource_col] <- static_player_resources[player_row,resource_col]+1
      }
      setGameData("player_resources", static_player_resources)

      # Exit before incrementing player number
      return(NULL)
    }
    if(new_build$build=="road"){
      setGameData("current_player", next_player)
    }
  })
  
  # Gameplay observeEvents and output$game_world ----
  output$game_world <- renderPlotly({
    print("Re-rendering game_world")
    globe_plates <- getGameData("globe_plates", print_value = FALSE)
    
    static_build_list <- getGameData("build_list")
    setup_build_data <- merge(static_build_list, marker_data_unmoved)
    
    color_table <- getGameData("color_table")
    colnames(color_table) <- c("owner", "pcolor")
    setup_build_data <- merge(setup_build_data, color_table)
    
    setup_build_list <- split(setup_build_data, seq_len(nrow(setup_build_data)))
    piece_list <- mapply(piece_maker, setup_build_data$build, setup_build_list, 
                         color=setup_build_data$pcolor, SIMPLIFY = FALSE)
    all_builds <- combine_geoms(list(globe_plates, combine_geoms(piece_list)))

    set_axis <- list(range=max(abs(globe_plates$vertices))*c(-1.05, 1.05),
                     autorange=FALSE, showspikes=FALSE,
                     showgrid=FALSE, zeroline=FALSE, visible=FALSE)
    # Maybe build ply() as a reactive object (static object?)
    # at the same time that the world itself is built?
    start_camera <- camera_eye()
    ply <- plot_ly(source = "game_world") %>%
      add_trace(type="mesh3d", data = all_builds,
                x=~vertices$x, y=~vertices$y, z=~vertices$z,
                i=~faces$i, j=~faces$j, k=~faces$k,
                facecolor=rgb(t(col2rgb(all_builds$faces$color)),
                              maxColorValue = 255),
                lighting=list(diffuse=1),
                hoverinfo="none") %>%
      layout(scene=list(
        xaxis=set_axis, yaxis=set_axis, zaxis=set_axis,
        aspectmode='cube',
        camera=list(eye=list(x=start_camera[1], y=start_camera[2], z=0.8)),
        bgcolor="black"
      ),
      margin=list(l=0, r=0, b=0, t=0, pad=0),
      showlegend=FALSE) %>%
      config(displayModeBar = FALSE)
    
    robber_init <- getGameData("robber_data")
    ply <- ply %>%
      add_trace(type="mesh3d", data = robber_init,
                x=~vertices$x, y=~vertices$y, z=~vertices$z,
                i=~faces$i, j=~faces$j, k=~faces$k,
                facecolor=rgb(t(col2rgb(robber_init$faces$color)),
                              maxColorValue = 255),
                lighting=list(diffuse=1),
                hoverinfo="none")
    
    # print(marker_data()())
    # print(my_marker_data())
    print(getGameData("marker_data"))
    setGameData("marker_data", getGameData("marker_data"))
    
    return(ply)
  })
  ed <- reactive(event_data(event = "plotly_click", source = "game_world"))
  observeEvent(ed(), {
    req(ed()$key) # Prevent clicks on the GLOBE (not markers) from registering
    print("game_world clicked!")
    if(ed()$key%in%1:60){
      if(ed()$key%in%build_list()()$id[build_list()()$build=="settlement"]){
        hovertext <- "Build a city here?"
      } else {
        hovertext <- "Build a settlement here?"
      }
    } else {
      hovertext <- "Build a road here?"
    }
    
    plotlyProxy("game_world") %>% plotlyProxyInvoke("deleteTraces", list(3))
    newtrace <- list(x = list(ed()$x), 
                     y = list(ed()$y), 
                     z=list(ed()$z), 
                     key=list(ed()$key), 
                     text=list(hovertext),
                     hoverinfo="text",
                     type = "scatter3d",
                     mode = "markers", 
                     marker=list(color="red", opacity=0.2, size=50))
    
    plotlyProxy("game_world") %>% plotlyProxyInvoke("addTraces", newtrace)
    
    if(robber_active()){
      updateActionButton(session, "move_robber", "Move the robber here", disabled = FALSE)
    } else {
      updateActionButton(session, "build_here", label = "Build here", disabled = FALSE)
    }
  })
  observeEvent(input$roll_dice, {
    number_rolled <- sum(sample(1:6, 1), sample(1:6, 1))
    gameLog(paste(input$uname, "rolled the dice"))
    
    if(number_rolled==7){
      print("Activating robber")
      face_markers <- marker_data_all[marker_data_all$lab=="face",]
      face_markers <- moveMarkerOutward(face_markers, 1.5)
      
      setGameData("marker_data", face_markers)
      robber_active(TRUE)
      setGameData("dice_rolled", TRUE)
      return(NULL) # trigger later marker_data from "move robber here" input instead
    }
    if(!robber_active()){
      print("Allocating resources based on roll")
      robber_basepoint <- cbind(id=0, getGameData("robber_data")$vertices[1,])
      face_spots <- marker_data_all[marker_data_all$lab=="face",c("id", "x", "y", "z")]
      rob_dists <- sweep(data.matrix(face_spots), 2, data.matrix(robber_basepoint), `-`)
      robber_face_id <- names(which.min(rowSums(abs(rob_dists[,c("x", "y", "z")]))))
      
      resource_layout <- getGameData("resource_layout")
      settle_resources <- build_list()()[build_list()()$build%in%c("settlement", "city"),] %>%
        merge(nearby_structures$verts)
      unlist_resources <- data.frame(
        vert_id=rep(settle_resources$id, each=3),
        owner=rep(settle_resources$owner, each=3),
        build=rep(settle_resources$build, each=3),
        id=unlist(settle_resources$nearest_faces)
      ) %>% 
        merge(resource_layout[c("id", "hex_resources", "pip")]) %>%
        .[.$hex_resources!="snow",] %>%
        .[.$pip==number_rolled,] %>%
        .[.$id!=robber_face_id,]
      dput(unlist_resources)
      
      if(nrow(unlist_resources)>0){
        print("Logging resource allocation")
        for(player_i in unique(unlist_resources$owner)){
          p_res <- table(unlist_resources$owner, unlist_resources$hex_resources)[player_i,,drop=FALSE]
          p_res <- p_res[, p_res>0, drop=FALSE]
          gameLog(paste(player_i, "received", paste(p_res, colnames(p_res), collapse = " and ")))
        }
      }
      
      static_player_resources <- getGameData("player_resources")
      # static_player_resources <- readRDS("game_files/QUNWYD/player_resources.rds")
      for(i in seq_len(nrow(unlist_resources))){
        player_row <- which(static_player_resources$uname==unlist_resources$owner[i])
        resource_col <- as.character(unlist_resources$hex_resources[i])
        if(unlist_resources$build[i]=="settlement"){
          static_player_resources[player_row,resource_col] <- static_player_resources[player_row,resource_col]+1
        } else if(unlist_resources$build[i]=="city"){
          static_player_resources[player_row,resource_col] <- static_player_resources[player_row,resource_col]+2
        } else {
          stop(paste("Unrecognized build type", unlist_resources$build[i]))
        }
      }
      setGameData("player_resources", static_player_resources)
      
      # We want to offer as build spots
      # 1) settlements that aren't too close to other settlements
      # 2) roads that are close to our own roads (but not already built)
      # 3) cities where our settlements have already been built
      # Only if the resources for this are available!
      print("Updating clickables after roll")
      setGameData("marker_data", getBuildSpots())
    }
    
    setGameData("dice_rolled", TRUE)
  })
  observeEvent(input$move_robber, {
    req(ed()$key)
    print("input$move_robber clicked")
    face_markers <- getGameData("marker_data")
    robber_row_data <- face_markers[face_markers$id==ed()$key,]
    robber_init <- piece_maker(piece_type = "robber", robber_row_data)
    
    setGameData("robber_data", robber_init)
    gameLog(paste(input$uname, "moved the robber"))
    
    robber_active(FALSE)
    
    # Add the correct markers back via marker_data()() update here
    # since they didn't get re-added before
    my_marker_data(FALSE)
    setGameData("marker_data", getBuildSpots())
  })
  observeEvent(input$build_here, {
    req(ed()$key)
    print("input$build_here clicked")
    updateActionButton(session, "build_here", label = "Build here", disabled = TRUE)
    marker_data_unmoved <- getGameData("marker_data_unmoved", print_value = FALSE)
    build_spot <- marker_data_unmoved[ed()$key,]
    
    static_player_resources <- getGameData("player_resources")
    prr <- which(static_player_resources$uname==input$uname)
    if(build_spot$lab=="edge"){
      build_type <- "road"
      static_player_resources$wood[prr] <- static_player_resources$wood[prr]-1
      static_player_resources$brick[prr] <- static_player_resources$brick[prr]-1
    }
    if(build_spot$lab=="vertex"){
      if(build_spot$id%in%build_list()()$id){
        build_type <- "city"
        static_player_resources$ore[prr] <- static_player_resources$ore[prr]-3
        static_player_resources$wheat[prr] <- static_player_resources$wheat[prr]-2
      } else {
        build_type <- "settlement"
        static_player_resources$wood[prr] <- static_player_resources$wood[prr]-1
        static_player_resources$brick[prr] <- static_player_resources$brick[prr]-1
        static_player_resources$wheat[prr] <- static_player_resources$wheat[prr]-1
        static_player_resources$wool[prr] <- static_player_resources$wool[prr]-1
      }
      static_player_resources$vp[prr] <- static_player_resources$vp[prr]+1
    }
    print("Updating player_resources()()")
    setGameData("player_resources", static_player_resources)
    
    print("Updating build_list()()")
    new_build <- data.frame(id=build_spot$id, owner=input$uname, build=build_type)
    setGameData("build_list", rbind(build_list()(), new_build))
    gameLog(paste(input$uname, "built a", build_type))
    
    print("Updating marker_data()()")
    setGameData("marker_data", getBuildSpots())
  })
  observeEvent(input$buy_devcard, {
    static_player_resources <- getGameData("player_resources")
    static_player_resources[static_player_resources$uname==input$uname, c("wool", "wheat", "ore")] <- 
      static_player_resources[static_player_resources$uname==input$uname, c("wool", "wheat", "ore")]-1
    dev_res <- sample(c(rep("knight", 3), "vp"), 1)
    if(dev_res=="knight"){
      static_player_resources[static_player_resources$uname==input$uname, "knights"] <- 
        static_player_resources[static_player_resources$uname==input$uname, "knights"]+1
    } else {
      static_player_resources[static_player_resources$uname==input$uname, "vp"] <- 
        static_player_resources[static_player_resources$uname==input$uname, "vp"]+1
    }
    setGameData("player_resources", static_player_resources)
    gameLog(paste(input$uname, "bought a development card"))
  })
  observeEvent(input$play_knight, {
    print("Knight played!")
    static_player_resources <- getGameData("player_resources")
    static_player_resources[static_player_resources$uname==input$uname, "knights"] <- 
      static_player_resources[static_player_resources$uname==input$uname, "knights"]-1
    setGameData("player_resources", static_player_resources)
    
    face_markers <- marker_data_all[marker_data_all$lab=="face",]
    face_markers <- moveMarkerOutward(face_markers, 1.5)
    setGameData("marker_data", face_markers)
    
    robber_active(TRUE)
    gameLog(paste(input$uname, "played a knight"))
    return(NULL)
  })
  observeEvent(input$end_turn, {
    plotlyProxy("game_world") %>% plotlyProxyInvoke("deleteTraces", list(3))
    plotlyProxy("game_world") %>% plotlyProxyInvoke("deleteTraces", list(2))
    
    cur_player_idx <- which(init_player_list()()$uname==input$uname)
    next_player_idx <- cur_player_idx%%nrow(init_player_list()())+1
    next_player <- init_player_list()()$uname[next_player_idx]
    setGameData("current_player", next_player)
    
    setGameData("dice_rolled", FALSE)
    gameLog(paste(input$uname, "ended their turn"))
  })
  
  # Trade related observeEvents and reactives ----
  n_wood <- reactiveVal(0)
  n_brick <- reactiveVal(0)
  n_wool <- reactiveVal(0)
  n_wheat <- reactiveVal(0)
  n_ore <- reactiveVal(0)
  observeEvent(input$wood_plus, {n_wood(n_wood()+1)})
  observeEvent(input$brick_plus, {n_brick(n_brick()+1)})
  observeEvent(input$wool_plus, {n_wool(n_wool()+1)})
  observeEvent(input$wheat_plus, {n_wheat(n_wheat()+1)})
  observeEvent(input$ore_plus, {n_ore(n_ore()+1)})
  observeEvent(input$wood_minus, {
    my_wood <- player_resources()()[player_resources()()$uname==input$uname,"wood"]
    n_wood(max(-my_wood, n_wood()-1))
  })
  observeEvent(input$brick_minus, {
    my_brick <- player_resources()()[player_resources()()$uname==input$uname,"brick"]
    n_brick(max(-my_brick, n_brick()-1))
  })
  observeEvent(input$wool_minus, {
    my_wool <- player_resources()()[player_resources()()$uname==input$uname,"wool"]
    n_wool(max(-my_wool, n_wool()-1))
  })
  observeEvent(input$wheat_minus, {
    my_wheat <- player_resources()()[player_resources()()$uname==input$uname,"wheat"]
    n_wheat(max(-my_wheat, n_wheat()-1))
  })
  observeEvent(input$ore_minus, {
    my_ore <- player_resources()()[player_resources()()$uname==input$uname,"ore"]
    n_ore(max(-my_ore, n_ore()-1))
  })

  observeEvent(input$offer_trade, {
    n_wood(0)
    n_brick(0)
    n_wool(0)
    n_wheat(0)
    n_ore(0)
    setGameData("game_status", "trade_offered")
    setGameData("trade_status", "init_deciding")
  })
  observeEvent(input$propose_trade, {
    proposed_trade <- data.frame(wood=n_wood(), brick=n_brick(), wool=n_wool(), wheat=n_wheat(), ore=n_ore())
    setGameData("proposed_trade", proposed_trade)
    trade_responses <- data.frame(uname=init_player_list()()$uname, response="Undecided")
    setGameData("trade_responses", trade_responses)
    setGameData("trade_status", "awaiting_response")
  })
  observeEvent(input$accept_proposal, {
    static_trade_data <- getGameData("trade_responses")
    static_trade_data$response[static_trade_data$uname==input$uname] <- "accept"
    setGameData("trade_responses", static_trade_data)
    updateActionButton(session, inputId = "accept_proposal", label = "Accept", disabled = TRUE)
    updateActionButton(session, inputId = "reject_proposal", label = "Reject", disabled = TRUE)
  })
  observeEvent(input$reject_proposal, {
    static_trade_data <- getGameData("trade_responses")
    static_trade_data$response[static_trade_data$uname==input$uname] <- "reject"
    setGameData("trade_responses", static_trade_data)
    updateActionButton(session, inputId = "accept_proposal", label = "Accept", disabled = TRUE)
    updateActionButton(session, inputId = "reject_proposal", label = "Reject", disabled = TRUE)
  })
  observeEvent(input$choose_partner, {
    req(input$trade_partner)
    
    static_player_resources <- getGameData("player_resources")
    static_player_resources[static_player_resources$uname==input$uname,
                            c("wood", "brick", "wool", "wheat", "ore")] <- 
      static_player_resources[static_player_resources$uname==input$uname,
                              c("wood", "brick", "wool", "wheat", "ore")] + proposed_trade()()
    static_player_resources[static_player_resources$uname==input$trade_partner,
                            c("wood", "brick", "wool", "wheat", "ore")] <- 
      static_player_resources[static_player_resources$uname==input$trade_partner,
                              c("wood", "brick", "wool", "wheat", "ore")] - proposed_trade()()
    setGameData("player_resources", static_player_resources)
    trade_responses <- data.frame(uname=init_player_list()()$uname, response="Undecided")
    
    given_res <- proposed_trade()()[, proposed_trade()()>0, drop=FALSE]
    given_res_summary <- paste(given_res, names(given_res), collapse = " and ")
    gameLog(paste(input$uname, "received", given_res_summary, "from", input$trade_partner))
    
    gotten_res <- proposed_trade()()[, proposed_trade()()<0, drop=FALSE]
    gotten_res_summary <- paste(-gotten_res, names(gotten_res), collapse = " and ")
    gameLog(paste(input$trade_partner, "received", gotten_res_summary, "from", input$uname))

    setGameData("trade_responses", trade_responses)
    setGameData("trade_status", "init_deciding")
    setGameData("game_status", "gameplay")
    setGameData("marker_data", getBuildSpots())
  })
  observeEvent(input$cancel_trade, {
    proposed_trade <- data.frame(wood=n_wood(), brick=n_brick(), wool=n_wool(), wheat=n_wheat(), ore=n_ore())
    setGameData("proposed_trade", proposed_trade)
    
    trade_responses <- data.frame(uname=init_player_list()()$uname, response="Undecided")
    setGameData("trade_responses", trade_responses)
    setGameData("game_status", "gameplay")
    setGameData("trade_status", "init_deciding")
  })
}


# if(dir.exists("game_files"))unlink("game_files", recursive = TRUE)
# if(!dir.exists("game_files"))dir.create("game_files")
# if(!file.exists("game_files/existing_game_ids.rds")){
#   saveRDS("ABC", "game_files/existing_game_ids.rds")
# }
# browseURL("http://127.0.0.1:5013/")
# browseURL("http://127.0.0.1:5013/")
shinyApp(ui, server, options = list(launch.browser=TRUE, port=5013))
